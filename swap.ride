{-# STDLIB_VERSION 3 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}
func getNumberByKey (key) = match getInteger(this, key) {
    case a: Int => 
        a
    case _ => 
        0
}


func getStringByKey (key) = match getString(this, key) {
    case a: String => 
        a
    case _ => 
        ""
}


func getBoolByKey (key) = match getBoolean(this, key) {
    case a: Boolean => 
        a
    case _ => 
        false
}


func getNumberByAddressAndKey (address,key) = match getInteger(addressFromStringValue(address), key) {
    case a: Int => 
        a
    case _ => 
        0
}


func getStringByAddressAndKey (address,key) = match getString(addressFromStringValue(address), key) {
    case a: String => 
        a
    case _ => 
        ""
}


func getBoolByAddressAndKey (address,key) = match getBoolean(addressFromStringValue(address), key) {
    case a: Boolean => 
        a
    case _ => 
        false
}


let pubKeyAdminsList = ["BLEoguzPVKVTfXxxT3W7Rqf8aUm2ggC9Vemd2MQawM2G", "FWVffYr2ALmHMejZm3WqeLz6Sdym3gLFGtJn4KTwyU5x", "3Wh2LaWcb5gg7K2pPcW3Ep6EAuRBzYkAgrdpt43jTDFa", "5WRXFSjwcTbNfKcJs8ZqXmSSWYsSVJUtMvMqZj5hH4Nc"]

let SENDTXEXPIRE = 30

let LISTSPLITSYMBOL = "_"

let LISTDATASYMBOL = "+"

let WAVELET = 100000000

let PAULI = 1000000

let PRICELET = 1000000

let NeutrinoAssetIdKey = "neutrino_asset_id"

let BondAssetIdKey = "bond_asset_id"

let AuctionContractKey = "auction_contract"

let LiquidationContractKey = "liquidation_contract"

let RPDContractKey = "rpd_contract"

let ContolContractKey = "control_contract"

let BalanceWavesLockIntervalKey = "balance_waves_lock_interval"

let BalanceNeutrinoLockIntervalKey = "balance_neutrino_lock_interval"

let MinWavesSwapAmountKey = "min_waves_swap_amount"

let MinNeutrinoSwapAmountKey = "min_neutrino_swap_amount"

let NodeOracleProviderPubKeyKey = "node_oracle_provider"

let RPDBalanceKey = "rpd_balance"

func getRPDContractBalanceKey (assetId) = ((RPDBalanceKey + "_") + toBase58String(assetId))


let PriceKey = "price"

let PriceIndexKey = "price_index"

let IsBlockedKey = "is_blocked"

func getPriceHistoryKey (block) = ((PriceKey + "_") + toString(block))


func getHeightPriceByIndexKey (index) = ((PriceIndexKey + "_") + toString(index))


let BalanceLockedkKey = "balance_lock_"

let WavesLockedBalanceKey = (BalanceLockedkKey + "waves")

let NeutrinoLockedBalanceKey = (BalanceLockedkKey + "neutrino")

func getRPDSnapshotContractBalanceKey (count,assetId) = ((((RPDBalanceKey + "_") + toBase58String(assetId)) + "_") + toString(count))


func getCancelLeaseTxReserveFeeKey (hash) = (("cancel_lease_tx_reserve_fee" + "_") + hash)


func getWavesLockedBalanceKey (owner) = ((WavesLockedBalanceKey + "_") + owner)


func getNeutrinoLockedBalanceKey (owner) = ((NeutrinoLockedBalanceKey + "_") + owner)


func getBalanceUnlockBlockKey (owner) = ("balance_unlock_block_" + owner)


func getRPDProfitKey (count) = (("rpd_profit" + "_") + toString(count))


func convertNeutrinoToWaves (amount,price) = fraction(fraction(amount, PRICELET, price), WAVELET, PAULI)


func convertWavesToNeutrino (amount,price) = fraction(fraction(amount, price, PRICELET), PAULI, WAVELET)


func convertWavesToBond (amount,price) = convertWavesToNeutrino(amount, price)


func convertJsonArrayToList (jsonArray) = split(jsonArray, ",")


let liquidationContract = getStringByKey(LiquidationContractKey)

let neutrinoAssetIdString = getStringByKey(NeutrinoAssetIdKey)

let neutrinoAssetId = fromBase58String(neutrinoAssetIdString)

let auctionContract = getStringByKey(AuctionContractKey)

let rpdContract = getStringByKey(RPDContractKey)

let controlContract = getStringByKey(ContolContractKey)

let priceIndex = getNumberByAddressAndKey(controlContract, PriceIndexKey)

let isBlocked = getBoolByAddressAndKey(controlContract, IsBlockedKey)

let nodeOracleProviderPubKey = fromBase58String(getStringByKey(NodeOracleProviderPubKeyKey))

let balanceWavesLockInterval = getNumberByKey(BalanceWavesLockIntervalKey)

let balanceNeutrinoLockInterval = getNumberByKey(BalanceNeutrinoLockIntervalKey)

let minWavesSwapAmount = getNumberByKey(MinWavesSwapAmountKey)

let minNeutrinoSwapAmount = getNumberByKey(MinNeutrinoSwapAmountKey)

let bondAssetId = fromBase58String("6nSpVyNH7yM69eg446wrQR94ipbbcmZMU1ENPwanC97g")

let deprecatedBondAssetId = fromBase58String("975akZBfnMj513U7MZaHKzQrmsEx5aE3wdWKTrHBhbjF")

let neutrinoContract = this

let currentPrice = getNumberByAddressAndKey(controlContract, PriceKey)

let neutrinoLockedBalance = getNumberByKey(NeutrinoLockedBalanceKey)

let wavesLockedBalance = getNumberByKey(WavesLockedBalanceKey)

let reserve = (wavesBalance(neutrinoContract) - wavesLockedBalance)

let neutrinoSupply = (((neutrinoLockedBalance + extract(assetInfo(neutrinoAssetId)).quantity) - assetBalance(neutrinoContract, neutrinoAssetId)) - assetBalance(addressFromStringValue(liquidationContract), neutrinoAssetId))

let surplus = (convertWavesToNeutrino(reserve, currentPrice) - neutrinoSupply)

let deficit = (neutrinoSupply - convertWavesToNeutrino(reserve, currentPrice))

func checkIsValidMinSponsoredFee (tx) = {
    let MINTRANSFERFEE = 100000
    let SponsoredFeeUpperBound = 1000
    let realNeutrinoFee = convertWavesToNeutrino(MINTRANSFERFEE, currentPrice)
    let minNeutrinoFee = (realNeutrinoFee * 2)
    let maxNeutrinoFee = fraction(realNeutrinoFee, SponsoredFeeUpperBound, 100)
    let inputFee = extract(tx.minSponsoredAssetFee)
    if (if ((inputFee >= minNeutrinoFee))
        then (maxNeutrinoFee >= inputFee)
        else false)
        then (tx.assetId == neutrinoAssetId)
        else false
    }


func getRPDContractBalance (assetId) = getNumberByAddressAndKey(rpdContract, getRPDContractBalanceKey(assetId))


func getPriceHistory (block) = getNumberByAddressAndKey(controlContract, getPriceHistoryKey(block))


func getHeightPriceByIndex (index) = getNumberByAddressAndKey(controlContract, getHeightPriceByIndexKey(index))


func getCancelLeaseTxReserveFee (hash) = getNumberByKey(getCancelLeaseTxReserveFeeKey(hash))


func getWavesLockedBalance (owner) = getNumberByKey(getWavesLockedBalanceKey(owner))


func getNeutrinoLockedBalance (owner) = getNumberByKey(getNeutrinoLockedBalanceKey(owner))


func getUnlockBalanceBlock (owner) = getNumberByKey(getBalanceUnlockBlockKey(owner))


func getRPDProfit (count) = getNumberByKey(getRPDProfitKey(count))


@Callable(i)
func swapWavesToNeutrino () = {
    let pmt = extract(i.payment)
    let account = toString(i.caller)
    if ((minWavesSwapAmount > pmt.amount))
        then throw((("The specified Waves amount is less than the required minimum of " + toString(minWavesSwapAmount)) + " wavelets."))
        else if (isDefined(pmt.assetId))
            then throw("Only Waves token is allowed for swapping.")
            else if (isBlocked)
                then throw("contract is blocked by EMERGENCY SHUTDOWN actions untill reactivation by emergency oracles")
                else if ((getUnlockBalanceBlock(account) > height))
                    then throw((("await " + toString((getUnlockBalanceBlock(account) - height))) + " blocks"))
                    else if (if (!=(getNeutrinoLockedBalance(account), 0))
                        then true
                        else !=(getWavesLockedBalance(account), 0))
                        then throw("please withdraw locked funds first")
                        else WriteSet([DataEntry(getWavesLockedBalanceKey(account), pmt.amount), DataEntry(getBalanceUnlockBlockKey(account), (height + balanceWavesLockInterval)), DataEntry(WavesLockedBalanceKey, (wavesLockedBalance + pmt.amount))])
    }



@Callable(i)
func swapNeutrinoToWaves () = {
    let pmt = extract(i.payment)
    let account = toString(i.caller)
    if ((minNeutrinoSwapAmount > pmt.amount))
        then throw((("The specified Neutrino amount is less than the required minimum of " + toString(minNeutrinoSwapAmount)) + " Neutrino cents."))
        else if (isBlocked)
            then throw("The contract is blocked by EMERGENCY SHUTDOWN. Please wait for reactivation by emergency oracles.")
            else if (!=(pmt.assetId, neutrinoAssetId))
                then throw("Only appropriate Neutrino tokens are allowed for swapping.")
                else if ((getUnlockBalanceBlock(account) > height))
                    then throw((("await " + toString((getUnlockBalanceBlock(account) - height))) + " blocks"))
                    else if (if (!=(getNeutrinoLockedBalance(account), 0))
                        then true
                        else !=(getWavesLockedBalance(account), 0))
                        then throw("please withdraw locked funds first")
                        else WriteSet([DataEntry(getNeutrinoLockedBalanceKey(account), pmt.amount), DataEntry(getBalanceUnlockBlockKey(account), (height + balanceNeutrinoLockInterval)), DataEntry(NeutrinoLockedBalanceKey, (neutrinoLockedBalance + pmt.amount))])
    }



@Callable(i)
func withdraw (account,index) = {
    let unlockHeight = getUnlockBalanceBlock(account)
    let userWavesLockedBalance = getWavesLockedBalance(account)
    let userNeutrinoLockedBalance = getNeutrinoLockedBalance(account)
    let indexHeight = getHeightPriceByIndex(index)
    let prevIndexHeight = getHeightPriceByIndex((index - 1))
    let priceByIndex = getPriceHistory(indexHeight)
    let spread = 0
    let neutrinoAmount = convertWavesToNeutrino(userWavesLockedBalance, (priceByIndex - spread))
    let wavesAmount = convertNeutrinoToWaves(userNeutrinoLockedBalance, (priceByIndex + spread))
    if (isBlocked)
        then throw("contract is blocked by EMERGENCY SHUTDOWN actions untill reactivation by emergency oracles")
        else if ((unlockHeight > height))
            then throw((("please wait for: " + toString(unlockHeight)) + " block height to withdraw WAVES funds"))
            else if (if (if ((index > priceIndex))
                then true
                else (unlockHeight > indexHeight))
                then true
                else if (!=(prevIndexHeight, 0))
                    then (prevIndexHeight >= unlockHeight)
                    else false)
                then throw(((((((((("invalid price history index: index=" + toString(index)) + " priceIndex=") + toString(priceIndex)) + " indexHeight=") + toString(indexHeight)) + " unlockHeight=") + toString(unlockHeight)) + " prevIndexHeight=") + toString(prevIndexHeight)))
                else if (if ((0 >= neutrinoAmount))
                    then (0 >= wavesAmount)
                    else false)
                    then throw("balance equals zero")
                    else ScriptResult(WriteSet([DataEntry(getWavesLockedBalanceKey(account), 0), DataEntry(getNeutrinoLockedBalanceKey(account), 0), DataEntry(WavesLockedBalanceKey, (wavesLockedBalance - userWavesLockedBalance)), DataEntry(NeutrinoLockedBalanceKey, (neutrinoLockedBalance - userNeutrinoLockedBalance))]), TransferSet([ScriptTransfer(addressFromStringValue(account), wavesAmount, unit), ScriptTransfer(addressFromStringValue(account), neutrinoAmount, neutrinoAssetId)]))
    }



@Callable(i)
func transferToAuction () = {
    let auctionNBAmount = (neutrinoSupply - assetBalance(addressFromStringValue(auctionContract), bondAssetId))
    let surplusWithLiquidation = (surplus - assetBalance(addressFromStringValue(liquidationContract), neutrinoAssetId))
    if (isBlocked)
        then throw("contract is blocked by EMERGENCY SHUTDOWN actions untill reactivation by emergency oracles")
        else if ((auctionNBAmount > (1 * PAULI)))
            then TransferSet([ScriptTransfer(addressFromStringValue(auctionContract), auctionNBAmount, bondAssetId)])
            else if ((surplusWithLiquidation >= (1 * PAULI)))
                then TransferSet([ScriptTransfer(addressFromStringValue(liquidationContract), surplusWithLiquidation, neutrinoAssetId)])
                else throw(((((((("bond were generated or do not need it. Deficit:" + toString(auctionNBAmount)) + "|") + toString(0)) + ". Surplus:") + toString(surplusWithLiquidation)) + "|") + toString(surplus)))
    }



@Callable(i)
func transfer (account) = {
    let pmt = extract(i.payment)
    TransferSet([ScriptTransfer(addressFromStringValue(account), pmt.amount, pmt.assetId)])
    }



@Callable(i)
func migrationUSDNB2NSBTSwap () = {
    let pmt = extract(i.payment)
    let account = i.caller
    if (!=(deprecatedBondAssetId, pmt.assetId))
        then throw("error: attempt to swap not USDNB tokens")
        else TransferSet([ScriptTransfer(account, (pmt.amount * PAULI), bondAssetId)])
    }


@Verifier(tx)
func verify () = {
    let id = toBase58String(tx.id)
    let count = (((if (sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String(pubKeyAdminsList[0])))
        then 1
        else 0 + if (sigVerify(tx.bodyBytes, tx.proofs[1], fromBase58String(pubKeyAdminsList[1])))
        then 1
        else 0) + if (sigVerify(tx.bodyBytes, tx.proofs[2], fromBase58String(pubKeyAdminsList[2])))
        then 1
        else 0) + if (sigVerify(tx.bodyBytes, tx.proofs[3], fromBase58String(pubKeyAdminsList[3])))
        then 2
        else 0)
    match tx {
        case leasingTx: LeaseCancelTransaction|LeaseTransaction => 
            sigVerify(leasingTx.bodyBytes, leasingTx.proofs[0], nodeOracleProviderPubKey)
        case sponsorTx: SponsorFeeTransaction => 
            if (checkIsValidMinSponsoredFee(sponsorTx))
                then (count >= 3)
                else false
        case _ => 
            (count >= 3)
    }
    }
